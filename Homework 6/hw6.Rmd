---
title: Homework 6
author: Ansel George
output: 
    pdf_document:
        highlight: kate
fontsize: 11pt
---

```{r, message=F}
library(Rglpk)
library(quadprog)

set.seed(10)
```

\newcommand{\norm}[1]{\left\lVert#1\right\rVert}

# Dantzig selector

\begin{align*}
\min_{\boldsymbol\beta} \norm{\boldsymbol\beta}_1 \textrm{ st. } |\boldsymbol{y}_i - \boldsymbol{x}_i^T \boldsymbol\beta | \leq \lambda \textrm{ for } i=1,\dots,n
\end{align*}

## Recast the problem into a linear programming.

The expression:

\begin{align*}
|\boldsymbol{y} - X\boldsymbol\beta| < \lambda \boldsymbol1
\end{align*}

can equivalently be expressed as the set of inequalities:

\begin{align*}
\boldsymbol{y} - X\boldsymbol\beta &\leq \lambda \boldsymbol1 + \boldsymbol{e} \\
-\boldsymbol{y} + X\boldsymbol\beta &\leq \lambda \boldsymbol1 + \boldsymbol{e}
\end{align*}

for some $\boldsymbol{e} \in \mathbb{R}^n$ where $\boldsymbol{e} > \boldsymbol{0}$.

Rearranging:

\begin{align*}
\boldsymbol{e} + X\boldsymbol\beta &\geq \boldsymbol{y} - \lambda \boldsymbol1 \\
\boldsymbol{e} - X\boldsymbol\beta &\geq -\boldsymbol{y} - \lambda \boldsymbol1
\end{align*}

which can then be converted into matrix form:

\[
\begin{bmatrix}
I & X \\
I & -X \\
\end{bmatrix}
\begin{bmatrix}
\boldsymbol{e} \\
\boldsymbol{\beta} \\
\end{bmatrix}
=
\begin{bmatrix}
\boldsymbol{y} - \lambda\boldsymbol{1} \\
-\boldsymbol{y} - \lambda\boldsymbol{1}
\end{bmatrix}
\]

Or:

\[
\boldsymbol{G}
\begin{bmatrix}
\boldsymbol{e} \\
\boldsymbol{\beta} \\
\end{bmatrix}
=
\begin{bmatrix}
\boldsymbol{y} - \lambda\boldsymbol{1} \\
-\boldsymbol{y} - \lambda\boldsymbol{1}
\end{bmatrix}
\]


These can be formulated as a linear programming problem:

\begin{align*}
\min_{\boldsymbol\beta,\boldsymbol{e}} \boldsymbol1^T\boldsymbol{e} \textrm{ where }& \boldsymbol{e} > \boldsymbol{0}\textrm{, and} \\
&\boldsymbol{G}
\begin{bmatrix}
\boldsymbol{e} \\
\boldsymbol{\beta} \\
\end{bmatrix}
=
\begin{bmatrix}
\boldsymbol{y} - \lambda\boldsymbol{1} \\
-\boldsymbol{y} - \lambda\boldsymbol{1}
\end{bmatrix}
\end{align*}


## Use R interface of a linear programming solver (such as `rmosek`, `cplex`,
  `Rglpk`, `clpAPI`).

*Follow the examples in Convex demo.pdf.*

```{r}
n <- 10
p <- 8

lambda <- rep(5, n)
y <- seq(1,n)
X <- matrix(ceiling(runif(n*p, 0, 2*n))-n, ncol=p, nrow=n)
# X <- matrix(ceiling(rnorm(n*p, 0, 5)), ncol=p, nrow=n)
```

```{r}
obj <- c(rep(1, n), rep (0, p))
G <- matrix (0, nrow = 2*n, ncol = n+p)
for (i in 1:n){
  G[i, i] <- 1.0
  G[i, (n+1):(n+p)] <- X[i, ]
  G[n+i, i] <- 1.0
  G[n+i, (n+1):(n+p)] <- -X[i, ]
}

direction <- rep (">=", 2*n)
rhs <- c((y-lambda), -(y+lambda))
bounds <- list(lower=list(ind=(n+1):(n+p), val <- rep(-Inf, p)))

soln <- Rglpk_solve_LP(obj, G, direction, rhs, bounds=bounds)
b <- soln$solution[(n+1):(n+p)]

soln$status      # return status of solver
sum(abs(b))      # 1-norm of b
abs(y - X %*% b) # check that |y - Xb| is less than lambda
```

Again with a different matrix $X$:

```{r}
X <- matrix(ceiling(rnorm(n*p, 0, 5)), ncol=p, nrow=n)
```

```{r}
obj <- c(rep(1, n), rep (0, p))
G <- matrix (0, nrow = 2*n, ncol = n+p)
for (i in 1:n){
  G[i, i] <- 1.0
  G[i, (n+1):(n+p)] <- X[i, ]
  G[n+i, i] <- 1.0
  G[n+i, (n+1):(n+p)] <- -X[i, ]
}

direction <- rep (">=", 2*n)
rhs <- c((y-lambda), -(y+lambda))
bounds <- list(lower=list(ind=(n+1):(n+p), val <- rep(-Inf, p)))

soln <- Rglpk_solve_LP(obj, G, direction, rhs, bounds=bounds)
b <- soln$solution[(n+1):(n+p)]

soln$status      # return status of solver
sum(abs(b))      # 1-norm of b
abs(y - X %*% b) # check that |y - Xb| is less than lambda
```


# Markowitz portfolio optimization

*Suppose there are $p$ assets held over a fixed period and let $\beta_j$ denote
the amount invested in the $j$-th asset. Let $R$ be a $p$-variate random
variable denoting the relative price change of each asset. We assume $R$ has
mean $\mu_R$ and covariance $\Sigma_R$.*

\begin{align*}
\min_{\boldsymbol\beta}\boldsymbol{\beta}^T \Sigma_R \boldsymbol\beta \textrm{ st. }& \boldsymbol\beta^T \boldsymbol\mu_R \geq 1 \\
  &\boldsymbol1^T \boldsymbol\beta = 1 \\
  &\boldsymbol\beta \geq \boldsymbol0
\end{align*}

*Can you implement Markowitz portfolio optimization using R interface of a
quadratic programming solver?*

The goal is to construct a portfolio with a maximum in return and minimum in
variance in return.

```{r}
n <- 8
p <- 8

X <- matrix(rnorm(n*n), ncol=n, nrow=n)
X <- X %*% t(X)
mu <- runif(n, 0, 2)
```

```{r}
d <- rep(0, p)
A <- rbind(rep(1, p), mu)
A <- rbind(A, diag(p))
rhs <- c(1, min(1, max(mu)), rep(0, p))
soln <- solve.QP (2*X, d, t(A), rhs, meq=1)
b <- soln$solution

sum(b)        # should sum to 1
b %*% X %*% b # variance in return
b %*% mu      # average return
```
