#include <algorithm>
#include <array>
#include <iostream>
#include <map>
#include <string>
#include <vector>

/* Hard-code array size for generating codon hash table. */
#define CODON_TABLE_SIZE 64

/* Hard-code the strings to be searched. */
static const std::string S1 = "GCTGCTGCTGCTAAACGTTTGGGGCAGTCGAT";
static const std::string S2 = "GGTGCTCCAAGCTTTTGAGTCTGCTAGTGTCAACCCT";
static const std::string S3 = "GTGGGCCCCCTAGCTAGCTAGCTGGGGCAC";
static const std::string S4 = "TGTCGCTGGCTGGACTGCTGATCGTAGTAG";

/* Hard-code the string to find in the above strings. */
static const std::string S = "TAGCTAGCT";

/* Define a struct for the hash table. It will contain a list of all sequences
 * used to generate the table, the table itself, and an integer count of the
 * number of sequences used to generate the hash table. */
struct global_hash_table
{
  std::vector<std::string> sequences;
  std::array<std::vector<std::tuple<int, int>>, CODON_TABLE_SIZE> table;
  int count = 0;
};

/* Define a struct to contain a subsequence match generated by querying the
 * hash table generated by the set of sequences. Contains the id number of the
 * sequence, the sequence itself, and the match string highlighing the matched
 * subsequenes. */
struct subsequence_match
{
  int id;
  std::string sequence;
  std::string match;
};

/* Map nucleotide character codes to integers. */
static std::map<char, int> dna = {
  { 'A', 0 },
  { 'C', 1 },
  { 'G', 2 },
  { 'T', 3 },
};

/* Hash function for converting codons (triplets) to integers. */
int
dna_hash(std::string triplet)
{
  if (triplet.size() != 3) {
    fprintf(stderr, "ERROR: non-triplet passed to dna_hash");
    exit(1);
  }

  int code =
    dna[triplet[0]] * (4 * 4) + dna[triplet[1]] * (4) + dna[triplet[2]];
  return (code);
}

/* Utility function for printing out the entire hash table. */
void
print_global_hash_table(global_hash_table* hash_table)
{
  for (int i = 0; i != CODON_TABLE_SIZE; i++) {
    if (hash_table->table[i].size() > 0) {
      std::cout << i << ": ";
      for (auto j = hash_table->table[i].begin();
           j != hash_table->table[i].end();
           j++) {
        std::cout << "(" << std::get<0>(*j) << ',' << std::get<1>(*j) << ") ";
      }
      std::cout << std::endl;
    }
  }
  return;
}

/* Function that takes as input the global hash table by reference and adds
 * another sequence to it. */
void
append_global_hash_table(struct global_hash_table* hash_table, std::string seq)
{
  int len = seq.size();

  // Update the hash_table cound and append the new sequence.
  hash_table->count = hash_table->count + 1;
  hash_table->sequences.push_back(seq);

  // Iterate over triplet windows. Each triplet is stored as a std::tuple
  // containing the id of the origin sequence and the position within it. They
  // are appended to a linked list stored at the index of the hash table
  // generated by the hash function.
  for (int i = 0; i != len - 2; i++) {
    std::string substring = seq.substr(i, 3);
    hash_table->table[dna_hash(substring)].push_back(
      std::tuple<int, int>(hash_table->count, i));
  }
  return;
}

/* Search for a substring in the global hash table and return any and all
 * matches. */
std::vector<struct subsequence_match>
substring_search(struct global_hash_table* hash_table, std::string substring)
{
  int len = substring.size();
  std::vector<std::vector<std::tuple<int, int, int>>> search_table;

  // Subset the global alignment by the motifs present in the sequence being
  // searched, and create a table of triplets (seq id, position of start of
  // sequence, position of start of motif).
  for (int i = 0; i != len - 2; i++) {
    std::string s = substring.substr(i, 3);
    std::vector<std::tuple<int, int, int>> v;
    for (auto j = hash_table->table[dna_hash(s)].begin();
         j != hash_table->table[dna_hash(s)].end();
         j++) {
      v.push_back(std::tuple<int, int, int>(
        std::get<0>(*j), (std::get<1>(*j)) - i, std::get<1>(*j)));
    }
    search_table.push_back(v);

    /* // Print the output
     * std::cout << i << ": ";
     * for (auto j = v.begin(); j != v.end(); j++) {
     *   std::cout << "(" << std::get<0>(*j) << ',' << std::get<1>(*j) << ','
     *             << std::get<2>(*j) << ") ";
     * }
     * std::cout << std::endl; */
  }

  std::vector<struct subsequence_match> matches;

  // For each tuple found in the set of linked lists found by subsetting the
  // global hash table by the triplets found in the subsequence, check whether
  // it is part of a sequence of contiguous triplets that all match the
  // contiguous set of triplets found in the subsequence.
  for (int i = 0; i < (int)search_table[0].size(); i++) {
    bool flag = true;

    // Find all table entries corresponding to the start of the subsequence.
    int id = std::get<0>(search_table[0][i]);
    int start = std::get<1>(search_table[0][i]);

    // Iterate through the rest of the hash table and check to see if the
    // sequence of triplets over the sequence is present in the global hash
    // table at the position specified by i.
    for (int j = 1; j < len - 2; j++) {
      std::tuple<int, int, int> node;
      node = *std::find(search_table[j].begin(),
                        search_table[j].end(),
                        std::tuple<int, int, int>(id, start, start + j));
      // If the global hash entry is not present, break out of the loop.
      if (node == (*search_table[j].end())) {
        flag = false;
        break;
      }
    }

    // If all required triplets were found in the hash table, regenerate the
    // stripts as a subsequence_match struct.
    if (flag == true) {
      struct subsequence_match match;
      match.sequence = hash_table->sequences[id - 1];
      match.id = id;
      match.match =
        std::string(start, '.') + substring +
        std::string(match.sequence.size() - substring.size() - start, '.');
      matches.push_back(match);
    }
  }

  return (matches);
}

/* Utility function for printing the members of a subsequence_match struct. */
void
print_substring_matches(std::vector<struct subsequence_match> matches)
{
  for (auto match = matches.begin(); match != matches.end(); match++) {
    std::cout << "Sequence " << match->id << ": " << std::endl;
    std::cout << match->sequence << std::endl;
    std::cout << match->match << std::endl;
    std::cout << std::endl;
  }
}

/* Do the thing. */
int
main(void)
{
  struct global_hash_table table;

  append_global_hash_table(&table, S1);
  append_global_hash_table(&table, S2);
  append_global_hash_table(&table, S3);
  append_global_hash_table(&table, S4);
  // print_global_hash_table(&table);

  std::vector<struct subsequence_match> matches = substring_search(&table, S);
  print_substring_matches(matches);

  return (0);
}
